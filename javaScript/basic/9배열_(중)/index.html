<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //배열의 메서드(배열이 가지고 있는 함수)
        //[1]객체 
        //배열--> 일반적으로 같은 타입의 데이터를 묶어서 사용 ==> 동적타입언어에서는 타입에 관계없이 사용함
        //객체는 특성(특징)들을 묶어서 줄 수 있고(속성), 해당 객체의 동작(메서드)도 정의해서 묶어줄 수 있음.


        const ar = [];
        ar.push('국어');
        ar.push('영어');
        ar.push('수학');

        console.log(ar) //['국어', '영어', '수학'], push는 배열 끝에 밀어넣는 것

        const arr = [1, 2, 3, 4, 5, 6]
        console.log(arr) //[1,2,3,4,5,6]

        //처음 값과 끝값
        const animals = ['tiger', 'alligator', 'elephant', 'dog', 'cat', 'sheep', 'hippo'];

        console.log(animals[0]) //처음값
        console.log(animals[4]) //cat
        console.log(animals.length) //7
        console.log(animals[animals.length - 1]) //맨 끝 값을 구하는 방법(전체 - 1, 마이너스 할 때는 무조건 띄워쓰기 적어주기)

        //undefined 값을 가지는 경우(error와 다름)
        console.log(animals[5]); //sheep
        console.log(animals[10]); //undefined(값이 없는 게 아님, 선언은 됐는데 할당되지 않은 것)

        // 콘솔 정리
        console.clear();

        //배열의 반복과 출력
        // 1. 전통적인 for 반복문
        // 2. for .. in, for .. of 반복문
        // 3. 배열명.foreach();
        // 4. spread Opreator(펼침 연산자) ... 

        // 1. 전통적인 for 반복문
        //const animals = ['tiger', 'alligator', 'elephant', 'dog', 'cat', 'sheep', 'hippo'];
        for (let i = 0; i < animals.length; i++) { //i+=1 또는 i=i+1라고 적어도 같은 의미(하나씩 커진다는 의미 외에 ++을 적는 일은 없음)


            console.log(animals[i])
        }

        // 2. for .. in, for .. of 반복문

        // 콘솔 정리
        console.clear();
        // for (let 변수(배열 안에 있는 아이템이 순서대로 변수로 호출됨) of 배열명){}
        for (let item of animals) {
            console.log(item) //tiger alligator elephant dog cat sheep hippo
        }


        for (let item in animals) {
            console.log(item) //0 1 2 3 4 5 6 --> index
            console.log(animals[item]) //tiger alligator elephant dog cat sheep hippo
        }

        // 3. 배열명.foreach(){});
        // 첫번째 매개변수(item) --> 아이템(item 안에 들어있는 각각의 요소들) 각각이 호출됨
        // 두번째 매개변수(ind) --> 아이템 각각의 index가 호출
        // 세번째 매개변수 --> 원배열 animals
        console.clear();
        animals.forEach(function (item, ind, oriarr) {
            //console.log(item)
            //console.log(ind)
            //console.log(oriarr)
        })

        animals.forEach(function (ele) {
            console.log(ele) //tiger alligator elephant dog cat sheep hippo
        })


        //화살표 함수로 변경하기
        //Arrow function(=>)
        //    animals.forEach((ele)=>{
        //     console.log(ele)
        //    })

        //명령문이 한 줄 일 땐 중괄호를 삭제할 수 있음
        //    animals.forEach((ele)=>
        //     console.log(ele)
        //    )

        //매개변수가 딱 한개일 때만 괄호 생략 가능(매개변수가 없는 경우도 불가능)
        //animals.forEach((ele)=>console.log(ele))
        animals.forEach(ele => console.log(ele))


        // 4. spread Opreator(펼침 연산자) ... 

        // 콘솔 정리
        console.clear();

        console.log(...animals)

        // 삽입과 삭제
        // push(),pop()--> 뒤에서 삽입하고 삭제
        // unshift(), shift() --> 앞에서 삽입하고 삭제 --> 쉬프트는 배열의 정렬에 사용
        let testAr = [1, 2, 3, 4, 5, 6];
        testAr.push(7)
        testAr.pop(7)
        testAr.pop()
        testAr.pop() //가장 마지막 아이템이 빠져나감
        console.log(testAr)

        testAr.unshift('a')
        console.log(testAr) //['a', 1, 2, 3, 4]

        testAr.shift()
        console.log(testAr) //[ 1, 2, 3, 4]
        testAr.shift()
        console.log(testAr) //[2, 3, 4]

        // split()메서드
        // 기능 --> 문자열을 배열로 리턴 --> 문자열에서 특정한 구분자를 기준으로 잘라내서 새로운 배열로 리턴
        // 사용 --> 문자열. split(구분자,limit)

        let someSt = "가랑잎이 솔잎더러 바스락거린다고 한다";
        // let splitted = someSt.split(" ");
        // console.log(splitted)//['가랑잎이', '솔잎더러', '바스락거린다고', '한다'], 띄어쓰기를 기준으로 리턴됨
        let splitted = someSt.split(" ", 2);
        console.log(splitted) //['가랑잎이', '솔잎더러']

        let someSt2 = "진도, 제주도, 거제도, 독도, 마라도";
        // let splitted2=someSt2.split(', ')
        // console.log(splitted2)//(5) ['진도', '제주도', '거제도', '독도', '마라도']

        let splitted2 = someSt2.split(', ', 4)
        console.log(splitted2) //['진도', '제주도','거제도, '독도'], 반점과 띄어쓰기를 기준으로 리턴됨

        //slice() 메서드 --> 비교하여 splice()메서드
        //slice, splice--> 둘은 비슷하나 차이점이 있다. --> slice()
        //메서드는 원본 배열을 수정하지 않음. --> 즉, 새로운 배열을 리턴

        //splice() --> 원본 배열을 수정함

        //1)사용법
        //slice(start)
        //slice(start, end)// end는 지정한 end 전까지를 잘라냄
        console.clear();
        let sliceArr = ['tiger', 'alligator', 'elephant', 'dog', 'cat', 'sheep', 'hippo'];

        //배열명.slice(1)//인덱스 1포함해서 그 뒤로는 모두 잘라냄

        let slideAr1 = sliceArr.slice(1)
        console.log(slideAr1) //'alligator', 'elephant', 'dog', 'cat', 'sheep', 'hippo'
        console.log(sliceArr) //원본보존


        let slideAr2 = sliceArr.slice(1, 4); //인덱스 1,2,3
        console.log(slideAr2) //['alligator', 'elephant', 'dog']

        const sliceNums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

        const slideArNum1 = sliceNums.slice(5); //숫자 5 X, 인덱스가 5인 것부터 잘라내겠다는 의미임
        console.log(slideArNum1) // [6, 7, 8, 9, 10]
        console.log(sliceNums) //[1,2,3,4,5,6,7,8,9,10];


        //splice() 메서드
        //배열의 기존 요소를 삭제하거나 교체하고자 할때 --> 새로운 요소를 추가--> 배열의 값을 변경
        // 원본을 수정, 잘라내고(삭제) 이어 붙이기 기능

        //사용법
        //splice(start, count(몇개를 잘라낼 것인가))
        //splice(start, count, 값1, 값2)//값1, 값2 -> 잘라낸 자리에 대체할 아이템

        //잘라낸 자리에 값들을 넣는 것


        //1)
        console.clear();
        const oriAr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

        //  const splicAr1=oriAr.splice(5);
        //  console.log(splicAr1)//6,7,8,9,10
        //  console.log("원본배열 : " + oriAr)//1,2,3,4,5

        //2)

        //  const splicAr2=oriAr.splice(4,3);
        //  console.log(splicAr2)//[5, 6, 7], 4라는 것은 인덱스 번호임
        //  console.log(oriAr)// [1, 2, 3, 4, 8, 9, 10]

        //3)
        const splicAr3 = oriAr.splice(3, 2, 'a', 'b', 'c');
        console.log(splicAr3) //[4, 5]
        console.log(oriAr) // [1, 2, 3, 'a', 'b', 'c', 6, 7, 8, 9, 10]

        //4)
        const oriStrings = ['홍길도', '이순신', '강감찬', '김유신', '임꺽정'];

        // const oristring1=oriStrings.splice(2,2,"세종대왕","을지문덕")
        // console.log(oristring1)//['강감찬', '김유신']
        // console.log(oriStrings)//['홍길도', '이순신', '세종대왕', '을지문덕', '임꺽정']

        //마이너스
        // const oristring2=oriStrings.splice(-2);//뒤에서 2개
        // console.log(oristring2)//['김유신', '임꺽정']
        // console.log(oriStrings)//['홍길도', '이순신', '강감찬']

        //0 --> 새로운 요소 삽입, 삭제하는 요소 없음
        const oristring3 = oriStrings.splice(3, 0, '광개토대왕');
        console.log(oristring3) //[] 
        console.log(oriStrings) //['홍길도', '이순신', '강감찬', '광개토대왕', '김유신', '임꺽정']

        // 배열 붙이기 concat() 메서드
        console.clear();
        const myArr1 = [1, 2, 3, 4];
        const myArr2 = [5, 6, 7, 8];

        const myArr12 = myArr1.concat(myArr2);
        console.log(myArr1) // [1, 2, 3, 4]
        console.log(myArr2) //[5, 6, 7, 8]
        console.log(myArr12) // [1, 2, 3, 4, 5, 6, 7, 8]

        const myArr21 = myArr2.concat(myArr1);
        console.log(myArr21) //[5, 6, 7, 8, 1, 2, 3, 4]

        //문자열

        const str1 = "Hello";
        const str2 = "JavaScript";
        console.log(str1.concat(str2)) //HelloJavaScript
        console.log(str1.concat(' ', str2)) //Hello JavaScript
        console.log(str1.concat(', ', str2)) //Hello, JavaScript
        console.log(str2.concat(', ', str1)) //JavaScript, Hello

        const someList = ['안녕', '', '난', '', '뽀로로야 ~', '!!'];
        console.log(...someList) //안녕 난 뽀로로야 ~ !!
        console.log(''.concat(...someList)) //안녕난뽀로로야 ~!!
        // ... --> 전개 연산자(spread operator):배열의 각 요소를 개별적인 인수로 전달한다.(안에 들어있는 요소들을 묶어서 전달한다고 생각하면 됨)

        //인덱스 몇 번째에 있는지 찾기--> indexof()메서드

        console.clear();

        const greatMan = ['홍길도', '이순신', '강감찬', '김유신', '임꺽정'];

        console.log(greatMan.indexOf('강감찬')) //2
        console.log(greatMan.indexOf('임꺽정')) //4
        console.log(greatMan.indexOf('임정')) //-1--> 없는 값을 indexOf()메서드로 찾으면 -1이 리턴(★)됨

        console.clear();
        let abcArl = "ABC DEFGHIJKLMN"; //띄워쓰기도 문자로 취급함

        console.log(abcArl.indexOf('H')) //8
        console.log(abcArl.indexOf('h')) //-1(대소문자 구분해야함)

        console.log(abcArl.lastIndexOf('H')) //8(역순으로 검사)

        let abcArr2 = "abcdABCD";

        console.log(abcArr2.lastIndexOf('A')); //4
        console.log(abcArr2.toLocaleUpperCase().indexOf('A')); //0
        //toLocaleUpperCase() --> 대문자로 변환, 맨 앞에 있는 A가 검색된거라 0
        console.log(abcArr2.toLocaleUpperCase().lastIndexOf('A')); //4, 뒤에서부터 검색하는데 A니까 4가 됨

        //indexOf 옵션 --> indexOf("찾을 특정 값", 시작할 위치)
        console.clear();
        const nums = ['k', 'o', 'r', 'e', 'a', 'u', 's', 'a']

        console.log(nums.indexOf('a')) //4
        console.log(nums.indexOf('a', 5)) //7(a를 찾는데 인덱스 5번부터 찾아라)
        //만약 'o','r','e'추가한 상황이라면
        //const nums = ['k', 'o', 'r', 'e', 'a', 'u', 's', 'a','o','r','e'];
        //console.log(nums.indexOf('a',8))//-1

        //반복문

        const nums2 = "abcdaasdfasdsasdfaabdasfjasdfja";

        const serchNumber = 'asdf';
        let startPosition = 0;
        let lasetResult = [];

        while (true) {
            let idxRst = nums2.indexOf(serchNumber, startPosition);

            if (idxRst == -1) {
                break;
            }
            lasetResult.push(idxRst);
            startPosition = idxRst + 1;
        }
        console.log("찾고자하는 인덱스는 " + lasetResult) //찾고자하는 인덱스는 5,13,25
        console.log("출현 빈도 수 " + lasetResult.length) //출현 빈도 수 3

        //배열에 특정 요소가 포함되어 있는지 없는지 알기 --> includes()

        const testArr = ['korea', 'usa', 'china', 'japan', 'canada'];

        console.log(testArr.includes('japan')) //true
        console.log(testArr.includes('mexico')) //false

        //배열내 요소들을 하나로 묶어주기 --> 그때, 문자열(String)타입으로 묶어주기-->join()
        console.clear();
        const testArr2 = ['korea', 'usa', 'china', 'japan', 'canada'];
        console.log(testArr2.join()) //아무 옵션도 넣지 않고 호출하면 배열 요소 각각을 콤마(,)로 공백 없이 묶어줌
        console.log(typeof testArr2.join()) //string
        console.log(testArr2.join('-')) //구분자로 각각의 요소극 구분하여 하나의 문자열로 이어줌
        console.log(testArr2.join(' '))
        console.log(testArr2.join(', '))
        console.log(testArr2.join('+'))
        console.log(testArr2.join('/'))


        //요소가 undefined, null이 있을때 join()메서드를 사용하면?--> 빈 문자열로 연결
        const testArr3 = ['korea', 'usa', undefined, 'china', 'japan', null, 'canada'];
        console.log(testArr3.join(', '))

        const testArr4 = [];
        console.log(testArr4.join(', ')) //""  출력되는 내용없음

        //배열을 거꾸로 출력하기-->reverse()
        const testArr5 = ['a', 'b', 'c', 'd', 'e'];
        console.log(testArr5.reverse()) //['e', 'd', 'c', 'b', 'a']

        //조건에 맞는 첫번째 요소 찾기 --> find() --> 콜백함수 사용.
        //만일 값이 없다면 undefined 반환

        console.clear();
        const testAr6 = [56, 34, 89, 95, 100, 90];

        //find() vs filter() 비교(차이점)
        //find() 메서드 --> 첫번째 요소의 값을 반환. 더 이상 순회하지 X
        //filter() 메서드 --> 계속 순회 o --> 조건에 맞는 값을 다 찾아줌

        //const rst1=testAr6.find(function(){}--콜백함수)
        //    const rst1=testAr6.find(function(ele){
        //         return ele>=80
        //    })

        //화살표 함수로 변경 방법(펑션이 사라지고 괄호 뒤 화살표)
        //    const rst1=testAr6.find((ele)=>{
        //         return ele>=80
        //    })

        //매개변수가 하나일때(괄호 자체 생략 가능)
        const rst1 = testAr6.find(ele => ele >= 80)

        console.log(rst1) //89

        let testAr7 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 3]
        let count = 0;
        const rst2 = testAr7.find(ele => {
            count++;
            return ele == 3;
        })
        console.log(`해당 메서드의 반복횟수는 = ${count}`) //해당 메서드의 반복횟수는 = 3
        console.log(rst2) //3
        console.log(typeof rst2) //number



        const rst3 = testAr7.filter(ele => {
            count++;
            return ele == 3;
        })
        console.log(`해당 메서드의 반복횟수는 = ${count}`) //해당 메서드의 반복횟수는 = 3

        console.log(rst3) //[3,3]
        console.log(typeof rst3) //object


        const cars = [{
                name: '테슬라',
                price: 2500
            },
            {
                name: '벤츠',
                price: 3500
            },
            {
                name: '테슬라',
                price: 5500
            },
            {
                name: '벤츠',
                price: 6600
            },
            {
                name: '아우디',
                price: 4500
            },
        ];



        // const searchvalue=cars.find(function(ele){
        //     return ele.price>4000
        // })

        //화살표함수(펑션 빼고 괄호 뒤에 화살표)
        // const searchvalue=cars.find((ele)=>{
        //     return ele.price>4000
        // })

        //매개변수가 하나일때(괄호 자체 생략 가능)
        const searchvalue = cars.find(ele => ele.price > 4000)

        console.log(searchvalue) //{name: '테슬라', price: 5500}

        const searchvalue2 = cars.find(ele => ele.name == '벤츠')
        console.log(searchvalue2) //{name:'벤츠',price:3500}

        //콜백함수

        //이름있는 함수
        function searchvalue(car) {
            return car.name == "테슬라"
        }

        //searchvalue(jj)(이름없는 함수)

        /* let searchvalue = function (car) {
            return car.name == "테슬라"
        }
        searchvalue(jj)  */
        //이름 없는 함수는 반드시 아래에서 사용해야함(둘의 차이는 호이스팅 가능 유무)

        console.log(cars.find(searchvalue)) //함수 자체가 들어있어야하기 때문에 괄호 열고 닫으면 안됨 주의


        //이름 있는 함수의 경우 함수 선언문을 사용하여 정의되어 있으므로 언제든 호출할 수 있음 
        //하지만 이름 없는 함수의 경우 변수에 할당되어야 하며, 변수에 할당된 이후에만 사용할 수 있다.
    </script>
</body>

</html>